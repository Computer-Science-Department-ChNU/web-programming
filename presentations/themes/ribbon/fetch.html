<!DOCTYPE html>
<html lang="uk">
<head>
    <title>Network requests</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }
    </style>
</head>
<body class="shower list">

<header class="caption">
    <h1>Network requests</h1>
</header>

<section class="slide">
    <h2>Навіщо відправляти мережеві запити на сервер?</h2>
    <img src="pictures/req.webp" width="70%">
</section>

<section class="slide">
    <h2>Network requests</h2>
    <p>JavaScript може відправляти мережеві запити на сервер та підвантажувати нову інформацію за потребою без
        перезавантаження сторінки.</p>
    <ul>
        <li>Відправляти замовлення,</li>
        <li>Завантажити інформацію про користувача,</li>
        <li>Отримати останні оновлення з сервера,</li>
        <li>…і т.д.</li>
    </ul>
</section>

<section class="slide">
    <h2>Network requests</h2>
    <p>Є загальний термін <b>“AJAX”</b> (абревіатура від Asynchronous JavaScript And XML) для мережевих запитів від
        JavaScript коду.</p>
    <p>Є кілька способів надіслати мережевий запит і отримати інформацію з сервера.</p>
    <ul>
        <li>Метод fetch() - <a href="https://caniuse.com/?search=fetch" target="_blank">підтримка</a></li>
        <li>Використання обєкту const xhr = new XMLHttpRequest();</li>
        <li>WebSocket (з’єднання є постійне)</li>
        <li>Server Side Events (з’єднання є постійне)</li>
    </ul>
</section>

<section class="slide">
    <h2>Метод fetch()</h2>
    <p>Базовий синтаксис: let promise = fetch(url, [options])</p>
    <ul>
        <li>url – URL для відправлення запиту.</li>
        <li>options – додаткові параметри: метод, заголовки і т.д</li>
    </ul>
    <p>Без options, це просто GET запит, який завантажує зміст за адресою url.</p>
    <p>Браузер одразу починає робити запит та повертає проміс, який зовнішний код використовує для отримання
        результату.</p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>Під час стандартного виконання JavaScript інструкції виконуються послідовно, одна за одною. Тобто спочатку
        виконується перша інструкція, потім друга і так далі. Однак уявімо ситуацію, якщо одна з цих операцій
        виконується тривалий час. Наприклад, вона виконує якусь високонавантажену роботу, як-от звернення через мережу
        або звернення до бази даних, що може зайняти невизначений і іноді тривалий час. У підсумку при послідовному
        виконанні всі наступні операції будуть очікувати виконання цієї операції. Щоб уникнути подібної ситуації,
        JavaScript дає змогу уникнути подібного сценарію за допомогою асинхронних функцій. <a
                href="../../../examples/fetch/1.html" target="_blank">Example 1</a>
    </p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>
        З <a href="../../../examples/fetch/1.html" target="_blank">Example 1</a> видно, що асинхронна функція <b>asyncFunction()</b>
        не блокує виконання інших інструкцій програми. Однак під час роботи з подібними функціями ми можемо зіткнутися з
        низкою проблем. Так, асинхронні функції не повертають результат асинхронного обчислення через ключове слово
        return, а передають його як параметр функції зворотного виклику <a href="../../../examples/fetch/2.html"
                                                                           target="_blank">Example 2</a>.
    </p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>
        Інша проблема пов'язана з генерацією помилок...
    </p>
    <p>Як обробляти помилки?</p>
</section>

<section class="slide">
    <h2>Обробка помилок</h2>
    <p>
        У процесі роботи програми можуть виникати різні помилки, які порушують хід виконання програми і навіть змушують
        її перервати виконання <a href="../../../examples/fetch/3.html" target="_blank">Example 3</a>.
    </p>
    <p>
        Однак коли ми маємо справу з великою програмою, різні шматки якої писали різні розробники, стає складніше
        контролювати код. І таких ситуацій може бути багато. Якісь ми можемо самі відстежити та попередити, а якісь ні.
    </p>
    <p>Мова JavaScript має інструменти для обробки таких ситуацій.</p>
</section>

<section class="slide">
    <h2>Конструкція try..catch..finally</h2>
    <pre>
        <code>try {</code>
        <code>  інструкції блоку try</code>
        <code>} catch (error) {</code>
        <code>  інструкції блоку catch</code>
        <code>} finally {</code>
        <code>  інструкції блоку finally</code>
        <code>}</code>
    </pre>
</section>

<section class="slide">
    <h2>Конструкція try..catch..finally</h2>
    <p>Після оператора try визначається блок коду (обов'язковий). У цей блок поміщаються інструкції, під час виконання
        яких може виникнути потенційна помилка.</p>
    <p>Потім іде оператор catch. Після цього оператора в круглих дужках вказується назва об'єкта, який міститиме
        інформацію про помилку. І далі йде блок catch. Цей блок виконується тільки в разі виникнення помилки в блоці
        try.</p>
    <p>Після блоку catch йде оператор finally зі своїм блоком інструкцій. Цей блок виконується в кінці після блоку try і
        catch незалежно від того, виникла помилка чи ні.</p>
    <p>Блок try є обов'язковим, а один із решти блоків - catch або finally ми можемо опустити: <a
            href="../../../examples/fetch/4.html" target="_blank">Example 4</a>, <a
            href="../../../examples/fetch/5.html" target="_blank">Example 5</a>, <a
            href="../../../examples/fetch/6.html" target="_blank">Example 6</a></p>
</section>

<section class="slide">
    <h2>Об’єкт помилки</h2>
    <p>Коли виникає помилка, JavaScript генерує об’єкт, що містить інформацію про неї. Потім цей об’єкт передається як
        аргумент в catch(err).</p>
    <p>Для всіх вбудованих помилок об’єкт помилки має дві головні властивості:</p>
    <ul>
        <li>name - назва помилки. Наприклад, для невизначеної змінної назва буде "ReferenceError".</li>
        <li>message - текстове повідомлення з додатковою інформацією про помилку.</li>
        <li>stack- поточний стек викликів: рядок з інформацією про послідовність вкладених викликів, що призвели до
            помилки. Використовується для налагодження.
        </li>
    </ul>
    <a href="../../../examples/fetch/7.html" target="_blank">Example 7</a>
</section>

<section class="slide">
    <h2>Оператор throw</h2>
    <p>Інтерпретатор JavaScript генерує помилки для низки ситуацій, наприклад, під час виклику неіснуючої функції, під
        час повторного присвоєння константі значення тощо. Але за потреби ми самі можемо генерувати помилки та визначити
        умови, коли генеруватиметься помилка.</p>
    <p>Оператор має синтаксис: throw <b>об’єкт помилки</b></p>
    <p>JavaScript має багато вбудованих конструкторів для вбудованих помилок: Error, SyntaxError, ReferenceError,
        TypeError та інші. Також вони можуть бути використаними для створення об’єктів помилок.</p>
    <a href="../../../examples/fetch/8.html" target="_blank">Example 8</a>
</section>

<section class="slide">
    <h2>Повторне викидання помилок</h2>
    <p>Використаємо try...catch, щоб обробити неправильні дані. Але чи може всередині блоку try {...} виникнути інша
        непередбачувана помилка? Програміст помилився і забув визначити змінну чи ще щось? <a
                href="../../../examples/fetch/9.html" target="_blank">Example 9</a></p>
    <p>Блок catch повинен оброблювати тільки відомі помилки та повторно генерувати всі інші типи помилок.</p>
    <ul>
        <li>Конструкція catch перехоплює всі помилки.</li>
        <li>В блоці catch (err) {...} ми аналізуємо об’єкт помилки err.</li>
        <li>Якщо ми не знаємо як правильно обробити помилку, ми робимо throw err.</li>
    </ul>
    <a href="../../../examples/fetch/10.html" target="_blank">Example 10</a>,
    <a href="../../../examples/fetch/11.html" target="_blank">Example 11</a>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>
        Інша проблема пов'язана з генерацією помилок через оператор throw: <a href="../../../examples/fetch/12.html"
                                                                              target="_blank">Example 12</a>
    </p>
    <p>
        Від самого початку обробка результату і помилок в асинхронних функціях представляло використання коллбеків
        (callback) - функцій зворотного виклику, які передавалися в іншу функцію і викликалися пізніше в деякий момент
        часу. Найпростіший шаблон використання коллбеків: <a href="../../../examples/fetch/13.html" target="_blank">Example
        13</a>, <a href="../../../examples/fetch/15.html" target="_blank">Example
        14</a>
    </p>
    <p>
        Наприклад, використовуємо колбек для отримання й обробки результату та помилки асинхронної функції: <a
            href="../../../examples/fetch/14.html" target="_blank">Example 15</a>
    </p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>
        <b>Callback (колбек, функція зворотного виклику)</b> - функція, яка викликається у відповідь на вчинення деякої
        події.
    </p>
    <p>Загалом, подією може бути що завгодно:</p>
    <ul>
        <li>відповідь від сервера;</li>
        <li>завершення якогось тривалого обчислювального завдання;</li>
        <li>отримання доступу до якихось API пристрою, на якому виконується код</li>
    </ul>
    <p>Таким чином колбек - це перший спосіб обробити будь-яку асинхронну дію.</p>
    <p>Однак у колбеків є неприємний мінус, так зване пекло колбеків (callback hell).</p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>Навіть якщо вам не потрібно працювати з сервером, досить високі шанси зіткнутися з функціями зворотного
        виклику.</p>
    <p>forEach, every, some, reduce, filter, або функції сортування sort, або методу addEventListener (другий параметр
        приймає функцію, яку буде викликано в разі настання події)</p>
    <p>Аналогічно з установкою обробників подій. Щоразу, коли ви підписуєтеся на подію за допомогою addEventListener,
        через її другий параметр ви визначаєте функцію зворотного виклику, яка спрацює під час настання події. У світі
        JavaScript колбеки всюди.</p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <ul>
        <li>
            Спочатку колбеки були єдиним способом працювати з асинхронним кодом у JavaScript. Велика частина
            асинхронного API Node.js була написана саме на колбеках і створена для використання з колбеками.
        </li>
        <li>
            Це, в принципі, логічно - ментальна модель досить проста: "виконай цю функцію, коли трапиться ця подія".
        </li>
        <li>Як передати параметри в колбек-функцію? <a
                href="../../../examples/fetch/16.html" target="_blank">Example 16</a>
        </li>
        <li>
            <a href="http://callbackhell.com/" target="_blank">callbackhell</a>, <a
                href="../../../examples/fetch/17.html" target="_blank">Example 17</a>
        </li>
        <li><a href="https://github.com/max-mapper/callback-hell" target="_blank">https://github.com/</a></li>
    </ul>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>
        <a href="../../../examples/fetch/18.html" target="_blank">Example 18</a>: функція setTimeout() не є
        частиною JavaScript-движка, це по суті <b>Web API</b>, включене в середовище браузера як додаткова
        функціональність.
    </p>
    <p>Ця додаткова функціональність (Web API) бере на себе роботу з таймерами, інтервалами, обробниками подій. Тобто
        коли ми реєструємо обробник кліка на кнопку - він потрапляє в оточення Web API. Саме воно знає, коли обробник
        потрібно викликати.</p>
    <p>Управління тим, як мають викликатися функції Web API, бере на себе цикл подій <b>(Event loop)</b>.</p>
    <p>Цикл подій відповідає за виконання коду, збір та обробку подій і виконання підзадач із черги.</p>
</section>

<section class="slide">
    <h2>Асинхронність, promise, async і await</h2>
    <p>
        Зауважте, що стек викликів і черга завдань називаються саме стеком і чергою. Тому що виклики зі стека працюють
        за принципом "останній зайшов, перший вийшов" (LIFO: last in, first out), а в черзі - за принципом "перший
        зайшов, перший вийшов" (FIFO: first in, first out).
    </p>
    <p>
        Черга - структура даних, у якій елементи впорядковані так, що перший елемент, який потрапив у чергу, залишає її
        першим.
    </p>
    <p>Таким чином цикл подій працює з асинхронним кодом - тобто таким, що виконується не построково.</p>
    <a href="http://latentflip.com/loupe/">http://latentflip.com/loupe/</a> - інструмент Loupe Филипа Робертса
</section>

<section class="slide">
    <h2>Проміси (Promise)</h2>
    <p>Проміс - це об'єкт-обгортка для асинхронного коду. Він містить у собі стан: спочатку pending ("очікування"),
        потім - один із: fulfilled ("виконано успішно") або rejected ("виконано з помилкою").</p>
    <p>У поняттях циклу подій проміс працює так само, як колбек: функція, що має виконатися (resolve або reject),
        перебуває в оточенні Web API, а в разі настання події - потрапляє до черги завдань, звідки потім - до стека
        виклику.</p>
    <p>Проміси придумали, щоб організовувати асинхронний код послідовно.</p>
    <p><a href="../../../examples/fetch/17.html" target="_blank">Example 17</a> - перепишемо з використанням промісів <a
            href="../../../examples/fetch/19.html" target="_blank">Example 19</a>.</p>
</section>

<section class="slide">
    <h2>Проміси (Promise)</h2>
    <p>Як пишеться? <a href="../../../examples/fetch/22.html" target="_blank">Example</a></p>
    <p>Проміс вирішує завдання виконання коду, який залежить від результату асинхронної операції.</p>
    <p>Проміс влаштований таким чином, що важелі управління його станом залишаються в асинхронної функції. Після
        створення, проміс перебуває в стані очікування pending. Коли асинхронна операція завершується, функція
        переводить проміс у стан успіху fulfilled або помилки rejected.
    </p>
    <p>За допомогою методів then(), catch() і finally() ми можемо реагувати на зміну стану промісу і використовувати
        результат його виконання.</p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Методи then(), catch() і finally()</h2>
    <p>
        У роботі ми частіше використовуємо проміси, ніж створюємо. Використовувати проміс - означає виконувати код під
        час зміни стану промісу.
        Існує три методи, які дають змогу працювати з результатом виконання обчислення всередині промісу:
    </p>
    <ul>
        <li>then()</li>
        <li>catch()</li>
        <li>finally()</li>
    </ul>
    <a href="../../../examples/fetch/19.html" target="_blank">Методи then(), catch() і finally()</a>
</section>

<section class="slide">
    <h2>Проміси (Promise). Метод then().</h2>
    <p>Метод then() використовують, щоб виконати код після успішного виконання асинхронної операції. <a
            href="../../../examples/fetch/23.html" target="_blank">Наприклад, ми запросили у сервера список постів і
        хочемо відобразити їх на екрані, коли сервер отримає результат.</a> У цьому випадку:</p>
    <ul>
        <li>асинхронна операція - запит даних у сервера;</li>
        <li>код, який ми хочемо виконати після її завершення - відображення списку.</li>
    </ul>
    <p>Метод then() приймає як аргумент дві функції-колбека. Якщо проміс у стані fulfilled, то виконається перша
        функція. Якщо в стані rejected - друга. Доброю практикою вважається не використовувати другий аргумент методу
        then() і обробляти помилки методом catch()</p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Метод catch().</h2>
    <p>
        Метод catch() використовують, щоб виконати код у разі помилки під час виконання асинхронної операції.
        <a href="../../../examples/fetch/24.html" target="_blank">Наприклад, ми запросили у сервера список постів і
            хочемо показати екран обриву з'єднання, якщо сталася помилка.</a> У цьому випадку:
    </p>
    <ul>
        <li>асинхронна операція - запит даних у сервера;</li>
        <li>код, який ми хочемо виконати в разі помилки - екран обриву з'єднання.</li>
    </ul>
    <p>Метод catch() приймає як аргумент функцію-колбек, яка виконується відразу після того, як проміс змінив стан на
        rejected. Параметр колбека містить екземпляр помилки. </p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Метод finally().</h2>
    <p>
        Метод finally() використовують, щоб виконати код під час завершення асинхронної операції. Він буде виконаний
        незалежно від того, була операція успішною чи завершилася помилкою.
    </p>
    <p>
        Найчастіший сценарій використання finally() - робота з індикаторами завантаження. Перед початком асинхронної
        операції розробник вмикає індикатор завантаження. Індикатор потрібно прибрати незалежно від того, як завершилася
        операція. Якщо цього не зробити, то користувач не зможе взаємодіяти з інтерфейсом.
    </p>
    <a href="../../../examples/fetch/25.html" target="_blank">Example</a>
</section>

<section class="slide">
    <h2>Проміси (Promise). Ланцюжки методів.</h2>
    <p>
        Методи then(), catch() і finally() часто об'єднують у ланцюжки викликів, щоб обробити і успішний, і помилковий
        сценарії: <a href="../../../examples/fetch/26.html" target="_blank">Example</a>
    </p>
    <p>
        У цьому разі в разі успішного завершення операції ми виконаємо код із then(), у разі помилки - код із catch().
        Потім виконається код з finally().
    </p>
    <p>Ланцюжки методів - дуже гнучкий підхід. Він дає змогу створювати залежні асинхронні операції.</p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Ланцюжки методів.</h2>
    <p>Наприклад, потрібно відобразити інформацію про фільм і головного героя. Ми не знаємо, хто головний герой, не
        отримавши цю інформацію з даних про фільм. Таким чином, запит даних про героя залежить від результату запиту
        даних про фільм.
        <a href="https://swapi.py4e.com/api/" target="_blank">swapi.py4e.com</a></p>
    <p>Проміси роблять рішення простим і читабельним. Ми можемо починати наступну асинхронну дію всередині колбека
        методу then(). Усе, що повертається з колбека, обертається в проміс, тому в ланцюжок можна додати новий then():
        <a href="../../../examples/fetch/27.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Як створити асинхронну функцію з промісом? <a href="../../../examples/fetch/28.html" target="_blank">Example</a>
    </h2>
    <p>Якщо асинхронна операція працює через колбеки, то її варто обернути в проміс, щоб писати код, який читається
        краще.</p>
    <p>Розглянемо приклад із функцією getData, яка приймає два колбеки: перший викликається в разі успіху, другий - у
        разі помилки. Код цієї функції може мати такий вигляд: <a href="../../../examples/fetch/29.html"
                                                                  target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Promise.all()</h2>
    <p>
        Метод all() - це один зі статичних методів об'єкта Promise. Метод all() використовують, коли потрібно запустити
        кілька промісів паралельно і дочекатися їхнього виконання: <a href="../../../examples/fetch/30.html"
                                                                      target="_blank">Example</a>
    </p>
    <p>Якщо хоча б один проміс із переданого масиву завершиться з помилкою, то Promise.all() теж завершиться з цією
        помилкою. Метод уже не стежитиме за виконанням промісів, що залишилися, які рано чи пізно все ж таки будуть
        виконані, і їхні результати будуть просто проігноровані: <a href="../../../examples/fetch/31.html"
                                                                    target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Promise.all()</h2>
    <p>
        Досить часте використання - це перетворення масиву з даними в масив із промісами за допомогою map(). У map() для
        кожного елемента створюється проміс, а потім отриманий масив передається в Promise.all(). Це дасть змогу
        дочекатися виконання всіх промісів, а потім обробити результат.
    </p>
    <p>Наприклад, можна використовувати метод Promise.all() для отримання даних кількох персонажів зі всесвіту зоряних
        віїн через запит до API: <a href="../../../examples/fetch/32.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Promise.allSettled()</h2>
    <p>Метод allSettled() - це один зі статичних методів об'єкта Promise. Його використовують, коли потрібно запустити
        кілька промісів паралельно і дочекатися їхнього виконання.</p>
    <p>Promise.allSettled() дуже схожий на метод Promise.all(), але працює трохи по-іншому. На відміну від
        Promise.all(), Promise.allSettled() чекає на виконання всіх промісів, при цьому неважливо, завершилися вони
        успішно чи з помилкою.</p>
    <p>Promise.allSettled() приймає ітеровану колекцію промісів (найчастіше - масив) і повертає новий проміс, який буде виконано, коли будуть виконані всі передані проміси. Отриманий проміс містить масив результатів виконання всіх переданих промісів, зберігаючи порядок оригінального масиву, але не порядок виконання: <a href="../../../examples/fetch/33.html" target="_blank">Example</a>,  <a href="../../../examples/fetch/34.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Проміси (Promise). Promise.any()</h2>
    <p>Метод any - це один зі статичних методів об'єкта Promise. Його використовують, коли потрібно запустити кілька промісів паралельно і дочекатися першого успішного дозволеного.</p>
   <p>На відміну від Promise.all(), який містить масив значень виконаних промісів, Promise.any() містить тільки одне значення (за умови, що хоча б один із промісів виконано успішно). Такий підхід може бути вигідним, коли потрібно, щоб виконався тільки один проміс, неважливо який.</p>
    <p>Для чого можна використовувати? Наприклад, у нас є 2 картинки і треба відобразити будь-яку з них, яка завантажиться швидше: <a href="../../../examples/fetch/35.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Проміси (Promise)</h2>
    <p>Проміси виявилися зручними, і з'явився навіть такий термін як "промісифікація" - коли асинхронну функціональність
        на колбеках перетворювали на проміси.</p>
    <p>У них є кілька недоліків:</p>
    <ul>
        <li>Код не такий лаконічний, як міг бути.</li>
        <li>У ланцюжку промісів, як на прикладі (зі стрілочними функціями), неможливо виставити брейкпоінт, бо немає
            тіла функції. Доводиться розкривати функцію.
        </li>
        <li>Стек помилок може містити в собі then.then.then.then.then.then....</li>
        <li>Вкладені умови сильно збільшують кількість коду і погіршують читабельність.</li>
    </ul>
    <p>
        Для вирішення цих проблем придумали асинхронні функції.
    </p>
</section>

<section class="slide">
    <h2>Асинхронні функції, async/await</h2>
    <p>Якщо коротко, асинхронні функції - функції, які повертають проміси.</p>
    <p>Асинхронна функція позначається спеціальним ключовим словом async: <a href="../../../examples/fetch/20.html"
                                                                             target="_blank">Example</a></p>
    <p>Усередині асинхронних функцій можна викликати інші асинхронні функції, без будь-яких then() або колбеків, за
        допомогою ключового слова await: <a href="../../../examples/fetch/21.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Асинхронні функції, async/await</h2>
    <p>Додане перед визначенням функції ключове слово async робить функцію асинхронною. Повернуте значення такої функції автоматично обертається в Promise:</p>
    <p>Асинхронні функції потрібні для виконання асинхронних операцій: роботи з API, базами даних, читання файлів тощо.</p>
    <p>Асинхронні операції виконуються не одразу: код надіслав запит до API і чекає, поки сервер надішле відповідь. Ключове слово await використовується, щоб дочекатися виконання асинхронної операції: <a href="../../../examples/fetch/36.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Асинхронні функції, async/await</h2>
    <p><a href="../../../examples/fetch/37.html" target="_blank">Example with Promises</a></p>
    <p><a href="../../../examples/fetch/38.html" target="_blank">Example with async/await</a></p>
    <ul>
        <li>він плоский;</li>
        <li>має вигляд, як синхронний;</li>
        <li>використовує стандартний блок try...catch для обробки помилок.</li>
    </ul>
    <p>Завжди використовуйте async/await замість ланцюжків then() і колбеків.
        Цей підхід простіше читається, легше налагоджується, користується стандартними способами обробки помилок.
    </p>
</section>

<section class="slide">
    <h2>fetch() - надсилаємо запити на сервер</h2>
    <p>
        За допомогою функції fetch() можна надсилати мережеві запити на сервер - як отримувати, так і надсилати дані. Метод повертає проміс з об'єктом відповіді, де міститься додаткова інформація (статус відповіді, заголовки) і відповідь на запит.
    </p>
    <p>
        Функція fetch() приймає два параметри:
        <br>
        1 - url - адреса, за якою потрібно зробити запит;
        <br>
        2 - options (необов'язковий) - об'єкт конфігурації, в якому можна налаштувати метод і тіло запиту, заголовки та багато іншого.
    </p>
    <p>
        За замовчуванням виклик fetch() робить GET-запит за вказаною адресою. Базовий виклик для отримання даних можна записати таким чином: <a href="../../../examples/fetch/39.html" target="_blank">Example</a>
    </p>
</section>

<section class="slide">
    <h2>fetch() - надсилаємо запити на сервер</h2>
    <p>За допомогою другого аргументу options можна передати налаштування запиту. Наприклад, можна змінити метод і додати тіло запиту, якщо ми хочемо не отримувати, а надсилати дані. Також у запит можна додати заголовки у вигляді об'єкта або спеціального класу Headers: <a href="../../../examples/fetch/40.html" target="_blank">Example</a></p>
    <p>Обробка помилок: <a href="../../../examples/fetch/41.html" target="_blank">Example</a></p>
    <p>
        За допомогою fetch() можна завантажувати файли на сервер, наприклад, коли користувач хоче завантажити свій аватар у профіль. Надсилання файлів можна здійснювати за допомогою спеціального об'єкта FormData. Покажемо на прикладі обробника відправлення форми: <a href="../../../examples/fetch/42.html" target="_blank">Example</a>
    </p>
</section>

<section class="slide">
    <h2>fetch() - надсилаємо запити на сервер</h2>
    <p>Скачування даних із результатом прогресу</p>
    <p>
        Щоб отримувати поточний прогрес скачування файлу або будь-яких інших даних, використовуйте властивість body об'єкта Response, який повертається в Promise після виклику fetch(). Поле body є "потоком для читання" (Readable Stream). Це спеціальний об'єкт, який дає можливість отримувати інформацію по частинах, у міру її надходження на клієнт.
    </p>
    <p> Спробуємо таким чином завантажити відео: <a href="../../../examples/fetch/43.html" target="_blank">Example</a></p>
</section>

<section class="slide">
    <h2>Робота з формами: надсилаємо запити на сервер</h2>
    <p>Загалом форма робоча <a href="../../../examples/fetch/44.html" target="_blank">(code)</a>: обов'язкові поля не пропустять порожні значення, атрибут type простежить, щоб замість пошти нам не надіслали номер телефону, а після натискання на кнопку валідна форма надішле всі дані.</p>
    <p>Але нам крім усього цього хочеться:</p>
    <ul>
        <li>щоб сторінка під час відправлення не перезавантажувалася;</li>
        <li>щоб під час запиту показувався лоадер, в разі успішного відправлення - привітання, а в разі помилки - причина помилки;</li>
        <li>щоб кнопка була заблокована доти, доки форма не валідна.</li>
    </ul>
</section>

<section class="slide">
    <h2 class="shout">The End</h2>
</section>

<div class="progress"></div>

<script src="../../shower.js"></script>
</body>
</html>
